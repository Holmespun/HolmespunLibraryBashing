# HolmespunMakefileMethod
# Holmespun-Makefile-Method
## Why Do You Care?
### Philosophy 1: Source code is golden
#### Discussion
#### Supported
## File Hierarchy
### Detail Directories
### Working Directories
## Make Targets
### Order Of Operation
### User Makefiles
### Usage Statement
## Configuration
### Mortar Variables
#### HOLMESPUN_MAKEFILE_SOURCES_DNAME
#### HOLMESPUN_MAKEFILE_TESTING_DNAME
#### HOLMESPUN_MAKEFILE_EXERCISE_MARK
### C++ Purpose and Verbosity
#### HOLMESPUN_MAKEFILE_PURPOSE
#### HOLMESPUN_MAKEFILE_DUMPAGE
## Repository Review
### Bash
### Bash/Library
### Bash/Profile
### Bash/Testing
### Make
### Make/Testing
### bin
# Command-Line Utility Test Framework
## Overview
### Demonstrative Output
#### Test Case Report
#### Test Case Definition
### clut_case_begin <name>
### clut_case_comment <text>
### clut_case_end
### clut_case_finalize <command>
### clut_case_initialize <command>
### clut_case_parameter <text>
### clut_case_stdin_source <file-name>
### clut_global_dump_format <extension> <function>
## Step 1: Create a project directory with a basic makefile.
## Step 2: Define a C++ class and compile it.
## Step 3: Define a unit test for our new class.
## Step 4: Create a program that uses the new class.
## Step 5: Create a Command-Line Utility Test (CLUT) for the new program.
## Step 6: Test-driven development.
## Copyright 2018 Brian G. Holmes
